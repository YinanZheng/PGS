list.of.packages <- c("gplots", "geepack", "lme4", "mvtnorm", "cvTools")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages) else print("All dependent packages are installed")

library(gplots)
library(geepack)
library(lme4)
library(mvtnorm)
library(cvTools)


generate_normal<-function(n, pn, m, str.y, beta.true, rho, sigma2)
{
  
  y.vect<-NULL
  x.mat<-NULL
  id.vect<-rep(1:n, each=m)
  
  R<-matrix(0,m,m)
  
  if(str.y=="exch")
    R<-matrix(rho,m,m)+diag(rep(1-rho,m))
  if(str.y=="ar1")
  {
    for (i in 1:m)
      R[i,]<-rho^(abs((1:m)-i))  
  }
  
  SIGMA<-sigma2*R
  
  X.sigma<-matrix(0,(pn-1),(pn-1))
{
    for (i in 1:(pn-1))
      X.sigma[i,]<-0.5^(abs((1:(pn-1))-i))  
  }

x.mat<-as.matrix(rmvnorm(n*m, mean=rep(0,(pn-1)), X.sigma))

x.mat<-cbind(rbinom(n*m,1, 0.5), x.mat)

y.temp<-x.mat%*%matrix(beta.true, ncol=1)
error<-rmvnorm(n, mean=rep(0,m),SIGMA)

y.vect<-y.temp+as.vector(t(error))   

id.vect<-rep(1:n, each=m) 

return(list(y.vect=y.vect, x.mat=x.mat, id.vect=id.vect, m=m, n=n, pn=pn, beta.true=beta.true, rho=rho, str.y=str.y))

}

q_scad<-function(theta,lambda,a=3.7)
{
  p<-length(theta)
  theta<-abs(theta)
  b1<-rep(0,p)
  b1[theta>lambda]<-1
  b2<-rep(0,p)
  b2[theta<(lambda*a)]<-1
  lambda*(1-b1)+((lambda*a)-theta)*b2/(a-1)*b1
}


S_H_E_normal<-function(y.vect, x.mat, id.vect, hat.R, beta.val, lam, eps)
{
  n<-length(unique(id.vect))
  m<-length(id.vect)/n
  
  
  
  
  resi<-as.vector(y.vect-x.mat%*%matrix(beta.val, ncol=1))
  sigma<-sqrt(sum(resi^2)/(dim(x.mat)[1]-dim(x.mat)[2]))
  
  S<-0
  H<-0
  
  for (i in 1:n)
  {
    X<-x.mat[((i-1)*m+1):(i*m),]
    Y<-matrix(y.vect[((i-1)*m+1):(i*m)],ncol=1)
    
    S<-S+sigma^(-2)*(t(X)%*%solve(hat.R)%*%(Y-X%*%matrix(beta.val, ncol=1)))
    H<-H+sigma^(-2)*(t(X)%*%solve(hat.R)%*%X)
    
  }
  
  E<-diag(q_scad(abs(as.vector(beta.val)), lam)/(abs(as.vector(beta.val))+eps)) 
  
  return(list(S=S, H=H, E=E,sigma=sigma, hat.R=hat.R))     
  
}






beta_shrink_normal<-function(y.vect, x.mat, hat.R, beta.ini, id.vect, lam, eps, eps.stop, max.step)
{
  
  n<-length(unique(id.vect))
  m<-length(y.vect)/n
  
  
  beta.new<-matrix(beta.ini, ncol=1)
  step.up<-0
  
  S.H.E.val<-S_H_E_normal(y.vect, x.mat, id.vect, hat.R, beta.new, lam, eps)
  S<-S.H.E.val$S
  H<-S.H.E.val$H
  E<-S.H.E.val$E
  
  while(step.up<max.step)
  {
    
    beta.old<-beta.new
    beta.new<-beta.old+solve(H+n*E+(1e-6)*diag(1,dim(H)[1]))%*%(S-n*E%*%beta.old)    
    S.H.E.val<-S_H_E_normal(y.vect, x.mat, id.vect, hat.R, beta.new, lam, eps)
    
    S<-S.H.E.val$S
    H<-S.H.E.val$H
    E<-S.H.E.val$E
    
    step.up<-step.up+1
    
    flag.stop<-sum(abs(beta.old-beta.new))
    
    
  }
  
  
  hat.R<-S.H.E.val$hat.R
  sigma<-S.H.E.val$sigma
  
  M<-0
  for (i in 1:n)
  {
    X<-x.mat[((i-1)*m+1):(i*m),]
    Y<-matrix(y.vect[((i-1)*m+1):(i*m)],ncol=1)
    
    EPS<-Y-X%*%matrix(beta.new, ncol=1)
    
    M<-M+sigma^(-4)*(t(X)%*%solve(hat.R+(1e-6)*diag(1,m))%*%(EPS%*%t(EPS))%*%solve(hat.R+(1e-6)*diag(1,m))%*%X)
  }
  
  var.sand<-diag(solve(H+n*E+(1e-6)*diag(1,dim(H)[1]))%*%M%*%solve(H+n*E+(1e-6)*diag(1,dim(H)[1])))
  
  return(list(beta.shrink=beta.new, beta.ini=beta.ini, var.sand=var.sand, flag.stop=flag.stop, est.sigma2=sigma^2))
  
} 

corr_est_normal<-function(y.vect, x.mat, n, m, beta.val, id.vect, corr.str)
{
  resi<-as.vector(y.vect-x.mat%*%matrix(beta.val, ncol=1))
  sigma<-sqrt(sum(resi^2)/(dim(x.mat)[1]-dim(x.mat)[2]))
  
  resi<-resi/sigma
  hat.R<-matrix(0, m, m)
  
  if(corr.str=="indep")
  {
    hat.R<-diag(rep(1,m))
  }
  
  
  
  if(corr.str=="exch")
  {
    
    SUM<-0
    for (i in 1:n)
    {  
      temp.resi<-resi[((i-1)*m+1):(i*m)]
      SUM_i<-0
      for(j in 1:m)
      {
        SUM_i<-SUM_i+(sum(temp.resi[j]*temp.resi)-temp.resi[j]^2)
        
      }
      SUM<-SUM+SUM_i/(m*(m-1))
      
    }
    alpha<-SUM/n
    
    hat.R<-matrix(alpha,m,m)+diag(rep(1-alpha,m))                     
  }
  
  
  if(corr.str=="ar1")
  {
    SUM<-0
    for (i in 1:n)
    {
      temp.resi<-resi[((i-1)*m+1):(i*m)]
      SUM<-SUM+sum(temp.resi[1:(m-1)]*temp.resi[2:m])/(m-1)
      
    } 
    alpha<-SUM/n
    
    for (i in 1:m)
      hat.R[i,]<-alpha^(abs((1:m)-i))  
    
  }
  
  
  if(corr.str=="unstructured")
  {
    resi.mat<-matrix(resi, nrow=n, ncol=m, byrow=T)
    hat.R<-t(resi.mat)%*%resi.mat/n
    diag(hat.R)<-rep(1,m)
    
  }
  
  return(hat.R)      
  
}

CV_lam_grid<-function(y.vect, x.mat, hat.R, beta.ini,id.vect, lam.vect, fold, eps, eps.stop, max.step)
{
  n<-length(unique(id.vect))
  m<-length(y.vect)/n
  
  lam.min<--1
  cv.min<-Inf
  cv.vect<-NULL
  
  for (j in 1:length(lam.vect))
  {
    lam.temp<-lam.vect[j]
    
    cv.value<-0            
    
    
    for (k in 1:fold)
    {
      index.cv<-index.cv.1<-m*c(1:n)[cvgrps$subsets[cvgrps$which==k]]
      for (i in 1:(m-1)){
        index.cv<-c(index.cv,index.cv.1-i)
      }
      
      y.train<-y.vect[-index.cv]
      x.train<-x.mat[-index.cv,]
      id.train<-id.vect[-index.cv]
      
      y.cv<-y.vect[index.cv]
      x.cv<-x.mat[index.cv,]
      id.cv<-id.vect[index.cv]
      
      beta.train<-beta_shrink_normal(y.train, x.train, hat.R, beta.ini, id.train, lam=lam.temp, eps, eps.stop, max.step)$beta.shrink
      
      cv.value<-cv.value+sum((y.cv-x.cv%*%matrix(beta.train, ncol=1))^2)
      #print(cv.value)    
    }
    print(cv.value)  
    cv.vect<-c(cv.vect, cv.value)
    
    if(cv.value<cv.min)
    {
      lam.min<-lam.temp
      cv.min<-cv.value
    }
    
  }
  
  return(list(lam.vect=lam.vect, cv.vect=cv.vect, 
              lam.min=lam.min, cv.min=cv.min))
  
} 

est_pgee_grid<-function(y.vect, x.mat, hat.R, beta.ini,id.vect, lam.vect, fold, eps, eps.stop, max.step)
{
  lam.cv<-CV_lam_grid(y.vect, x.mat, hat.R, beta.ini,id.vect, lam.vect, fold, eps, eps.stop, max.step)
  lam.sel<-lam.cv$lam.min
  lam.cv.vector<-lam.cv$cv.vect
  
  beta.fit<-beta_shrink_normal(y.vect, x.mat, hat.R, beta.ini, id.vect, lam=lam.sel, eps, eps.stop, max.step)
  return(list(
    lam.cv.vector=lam.cv.vector,
    beta.shrink=beta.fit$beta.shrink,
    var.sand=beta.fit$var.sand, 
    flag.stop=beta.fit$flag.stop, 
    lam.sel=lam.sel, est.sigma2=beta.fit$est.sigma2))
}

one_run_grid<-function(y.vect, x.mat, id.vect, n, pn, m, rho,lam.vect, fold, eps, eps.stop, max.step)
{
  
  beta.fit.indep<-est_pgee_grid(y.vect, x.mat, diag(rep(1,m)), beta.ini=rep(0, dim(x.mat)[2]),id.vect, lam.vect, fold, eps, eps.stop, max.step)
  
  hat.R.ar1<-corr_est_normal(y.vect, x.mat, n, m, beta.fit.indep$beta.shrink, id.vect, corr.str="ar1")
  
  beta.fit.ar1<-est_pgee_grid(y.vect, x.mat, hat.R.ar1,beta.ini=rep(0, dim(x.mat)[2]),id.vect,lam.vect, fold, eps, eps.stop, max.step)
  lam.cv.vector<-beta.fit.ar1$lam.cv.vector
  
  return(list(lam.cv.vector=lam.cv.vector,
              
              beta.shrink.ar1=as.vector(beta.fit.ar1$beta.shrink),
              
              var.sand.ar1=beta.fit.ar1$var.sand,
              
              flag.stop.ar1=beta.fit.ar1$flag.stop,
              
              lam.sel.ar1=beta.fit.ar1$lam.sel,
              
              alpha.ar1=hat.R.ar1[1,2],
              
              est.sigma2.ar1=beta.fit.ar1$est.sigma2              
  ))
  
  
} 

sim.grid<-function(run, n, pn, m, str.y, beta.true, rho, sigma2, lam.vect,Pm.vect, fold, eps, eps.stop, max.step)
{ 
  Beta.shrink.ar1.mat<-NULL
  Var.sand.ar1.mat<-NULL
  Flag.stop.ar1.vect<-NULL
  
  Alpha.ar1.vect<-NULL
  Est.sigma2.ar1.vect<-NULL
  
  GRID.ERR<-NULL
  LAM.SEL<-NULL
  
  for (i in 1:run)
  {
    print(i)
    
    grid.err<-matrix(nrow=length(Pm.vect),ncol=length(lam.vect))
    lam.sel<-NULL
    beta.shrink.ar1.mat<-NULL
    var.sand.ar1.mat<-NULL
    flag.stop.ar1.vect<-NULL
    
    alpha.ar1.vect<-NULL
    est.sigma2.ar1.vect<-NULL
    
    
    data.temp<-generate_normal(n, pn, m, str.y, beta.true, rho, sigma2)
    y.vect<-data.temp$y.vect
    x.mat<-data.temp$x.mat
    id.vect<-data.temp$id.vect 
    
    cvgrps<-cvFolds(n, K = fold,type = "random")
    
    for (k in 1:length(Pm.vect)){
      pm<-Pm.vect[k]
      print(pm)
      temp.run<-one_run_grid(y.vect, x.mat[,1:pm], id.vect, n, pm, m, rho, lam.vect, fold, eps, eps.stop, max.step)
      
      grid.err[k,]<-temp.run$lam.cv.vect
      lam.sel=c(lam.sel, temp.run$lam.sel.ar1)
      
      beta.shrink.ar1.mat=c(beta.shrink.ar1.mat, temp.run$beta.shrink.ar1)
      var.sand.ar1.mat=c(var.sand.ar1.mat, temp.run$var.sand.ar1)
      flag.stop.ar1.vect=c(flag.stop.ar1.vect, temp.run$flag.stop.ar1)
      
      alpha.ar1.vect=c(alpha.ar1.vect, temp.run$alpha.ar1)
      est.sigma2.ar1.vect<-c(est.sigma2.ar1.vect, temp.run$est.sigma2.ar1)
      
    }
    LAM.SEL<-rbind(LAM.SEL,lam.sel)
    GRID.ERR<-rbind(GRID.ERR,grid.err)
    
    Beta.shrink.ar1.mat<-rbind(Beta.shrink.ar1.mat,beta.shrink.ar1.mat)
    Var.sand.ar1.mat<-rbind(Var.sand.ar1.mat,var.sand.ar1.mat)
    Flag.stop.ar1.vect<-rbind(Flag.stop.ar1.vect,flag.stop.ar1.vect)
    
    Alpha.ar1.vect<-rbind(Alpha.ar1.vect,alpha.ar1.vect)
    Est.sigma2.ar1.vect<-rbind(Est.sigma2.ar1.vect,est.sigma2.ar1.vect)
    
    write.table(GRID.ERR,"GRIDERR")
    write.table(LAM.SEL,"LAMSEL")
    write.table(Beta.shrink.ar1.mat,"Beta.shrink.ar1")
    write.table(Var.sand.ar1.mat,"Var.sand.ar1.mat")
    write.table(Flag.stop.ar1.vect,"Flag.stop.ar1.vect")
    write.table(Alpha.ar1.vect,"Alpha.ar1.vect")
    write.table(Est.sigma2.ar1.vect,"Est.sigma2.ar1.vect")
  }
  return(list(beta.true=beta.true,
              str.y=str.y,
              rho=rho,
              n=n,
              pn=pn,
              m=m,
              lam.vect=lam.vect, 
              fold=fold,
              sigma2=sigma2,
              
              Beta.shrink.ar1.mat,
              Var.sand.ar1.mat,
              Flag.stop.ar1.vect,
              Alpha.ar1.vect,
              Est.sigma2.ar1.vect,
              
              GRID.ERR,
              LAM.SEL
  ))
  
  
}

PGS<-function(y.vect,          #### Dependent variable vector
              id.vect,         #### Subjuect id variable to indicate repeated measures
              M,               #### Biomarkers matrix (each row represents samples, each column represents biomarkers/probes)
              COV,	       #### Covariates matrix
              PS,	       #### Prescreening results. Should have been properly ranked. The first column must be the biomarkers name and must be the same as the column names of biomarkers matrix)
              Pm.vect,         #### Pm vector, a vector of the number of top ranking biomarkers 	       
              lam.vect,        #### lambda vector, a vector of PGEE penalty parameter
              n,               #### Sample size
              m,               #### Number of repeated measures
              rho=0.3,         ####
              fold=20,         #### 20-fold cross-validation for calculating grid error
              sigcut=10^-3,    #### If PGS estimate of biomarker is greater than 0.001, then the biomarker is selected 
              eps=10^-10,      ####
              eps.stop=0,      ####
              max.step=50,     ####
              str.y="ar1"      ####
){
  mirnames=colnames(M)
  conf.names=colnames(COV)
  
  grid.err<-matrix(nrow=length(Pm.vect),ncol=length(lam.vect))   ### Initiate error grid
  lam.sel<-NULL                ### Initiate optimized lambda
  beta.shrink.ar1.mat<-NULL    ### Initiate Beta (coefficient) estimates 
  var.sand.ar1.mat<-NULL       ### Initiate Variance 
  
  flag.stop.ar1.vect<-NULL     
  alpha.ar1.vect<-NULL         
  est.sigma2.ar1.vect<-NULL    
  
  mirnas.ps<-M[,PS[,1]] 
  
  for (k in 1:length(Pm.vect)){
    pm<-Pm.vect[k]
    print(pm)
    x.mat.1<-mirnas.ps[,1:pm]
    x.mat<-as.matrix(cbind(x.mat.1,COV))
    
    temp.run<-one_run_grid(y.vect, x.mat, id.vect, n, pm+ncol(COV), m, rho, lam.vect, fold, eps, eps.stop, max.step)
    
    grid.err[k,]<-temp.run$lam.cv.vect/fold
    lam.sel=c(lam.sel, temp.run$lam.sel.ar1)
    
    beta.shrink.ar1.mat=c(beta.shrink.ar1.mat, temp.run$beta.shrink.ar1)
    var.sand.ar1.mat=c(var.sand.ar1.mat, temp.run$var.sand.ar1)
    flag.stop.ar1.vect=c(flag.stop.ar1.vect, temp.run$flag.stop.ar1)
    
    alpha.ar1.vect=c(alpha.ar1.vect, temp.run$alpha.ar1)
    est.sigma2.ar1.vect<-c(est.sigma2.ar1.vect, temp.run$est.sigma2.ar1)
  }
  beta.shrink<-beta.shrink.ar1.mat
  var<-var.sand.ar1.mat
  grid.err<-grid.err
  #write.csv(beta.shrink,"beta.csv")     # Save the beta estimates
  #write.csv(var,"var.csv")        # Save the variance estimates
  
  rownames(grid.err)<-Pm.vect  
  colnames(grid.err)<-lam.vect
  write.csv(grid.err,"grid.csv")    # Save the CV-error grid
  print("Cross-validation error grid saved")
  
  best.ind<-which(grid.err==min(grid.err),arr.ind=T)
  print(paste0("The best selection results achieved using top ",Pm.vect[best.ind[1]]," biomarkers with lambda = ",lam.vect[best.ind[2]]))
  MinPm<-rowSums(grid.err==min(grid.err))
  Pm<-MinPm%*%Pm.vect    # selected best Pm
  
  start<-c(0,cumsum(Pm.vect)[-length(Pm.vect)])+1+seq(1:length(Pm.vect))*ncol(COV)-ncol(COV)
  end<-cumsum(Pm.vect)+seq(1:length(Pm.vect))*ncol(COV)
  
  start1<-MinPm%*%start
  end1<-MinPm%*%end
  beta<-as.numeric(beta.shrink.ar1.mat[start1:end1])
  varb<-as.numeric(var.sand.ar1.mat[start1:end1])
  beta1<-(abs(beta)>sigcut)
  
  mirnames.ps<-mirnames[PS[,1]]
  sel.names<-c(mirnames.ps[1:Pm],conf.names)[beta1]
  est<-beta[beta1]
  se<-sqrt(varb[beta1])
  effects<-data.frame(sel.names,est,se)
  
  write.csv(effects,"effects.csv")   # Save the final selection results 
  print("Final PGS selected results saved")
}

