##### 
#####

### Initiate a folder for storing the results
setwd("YourPath/")

### Install Package "RCurl" to access dataset and source R code from GitHub
#install.packages("RCurl")
require("RCurl")

### Install Package "qvalue" to calculate FDR q-values for site-by-site testing
#source("http://bioconductor.org/biocLite.R")
#biocLite("qvalue")
require("qvalue")

### Load PGS functions
script <- getURL("https://raw.githubusercontent.com/feizhe/PGS/master/functions",ssl.verifypeer = FALSE)
eval(parse(text = script),envir=.GlobalEnv)

### Load Sample data
DATA<-read.csv(text=getURL("https://raw.githubusercontent.com/feizhe/PGS/master/SampleData.csv",ssl.verifypeer = FALSE))

y.vect<-DATA$FEV1      ### Extract dependent variable
id.vect<-DATA$SID      ### Extract subjuect id variable to indicate repeated measures
M<-as.matrix(DATA[,4:169])        ### Extract microRNA data matrix (row=samples, column=miRNA probes)
COV<-as.matrix(DATA[,170:179])    ### Extract covariate data matrix
mirnames=colnames(M)              ### Extract miRNA names
conf.names=colnames(COV)          ### Extract confounder names


##########---- Standardization of miRNAs  ----##########
## (Since the example miRNA data have been normalized, we can skip this step) ##

#M<-scale(M)

##########---- Site-by-site test/Pre-screening with LMM ----##########

ps_lmm<-matrix(ncol=3,nrow=ncol(M))
for(i in 1:ncol(M)){
  g1<-lmer(y.vect~M[,i]+COV+(1|id.vect))      ###########adjusted for the 10 confounders
  ps_lmm[i,2]<-summary(g1)$coefficients[2,1]  #######point estimate
  ps_lmm[i,3]<-summary(g1)$coefficients[2,3]  #######t value
}
ps_lmm[,1]<-seq(from=1,to=ncol(M))  
rownames(ps_lmm)<-colnames(M)
ps_lmm<-ps_lmm[order(-abs(ps_lmm[,3])), ]         #######order by t values
colnames(ps_lmm)<-c("ID","estimate","t-value")
pvalue<-2*(1-pnorm(abs(ps_lmm[,3])))
ps_lmm<-data.frame(cbind(ps_lmm,pvalue))

ps_lmm$BH.FDR=p.adjust(ps_lmm$pvalue,"fdr")     #######calculate Benjamini and Hochberg FDR
ps_lmm$qvalue=qvalue(ps_lmm$pvalue)$qvalues     #######calculate FDR q-values

write.csv(ps_lmm,"PS_LMM.csv")


###########---- Site-by-site test/Pre-screening with GEE ----##########

ps_gee<-matrix(ncol=3,nrow=ncol(M))
for(i in 1:ncol(M)){
  g1<-geeglm(y.vect~M[,i]+COV,id=id.vect)
  ps_gee[i,2]<-summary(g1)$coefficients[2,1]
  ps_gee[i,3]<-summary(g1)$coefficients[2,4]
}
ps_gee[,1]<-seq(from=1,to=ncol(M),by=1)
rownames(ps_gee)<-colnames(M)
ps_gee<-data.frame(ps_gee[order(ps_gee[,3]), ])    #######order by p values
colnames(ps_gee)<-c("ID","estimate","pvalue")

ps_gee$BH.FDR=p.adjust(ps_gee$pvalue,"fdr")       #######calculate Benjamini and Hochberg FDR
ps_gee$qvalue=qvalue(ps_gee$pvalue)$qvalues       #######calculate FDR q-values

write.csv(ps_gee,"PS_GEE.csv")


########################---- Penalized GEE with Grid Search (PGS) ----########################

n=120   ### Sample Size
m=2     ### Repeated measurement times

cvgrps<-cvFolds(n, K = 20,type = "random")  ### Generate a 20-fold cross validation scheme

PS<-read.csv("PS_LMM.csv")   ### Import LMM prescreening results (LMM-based PGS)
#PS<-read.csv("PS_GEE.csv")  ### Import GEE prescreening results (GEE-based PGS)

PM<-c(seq(1:8)*20-10,166)      ### Initiate Pm sequence
lam.vect<-seq(0.06,0.24,0.02)  ### Initiate lambda sequence

### Run PGS
PGS(y.vect,M,COV,PS,PM,lam.vect,n,m)


########################---- Visualize the Grid Search results with heat plot ----########################
grid.err<-read.csv("grid.csv",row.names=1,check.names=F)  # Import the error grid
best.ind=which(grid.err==min(grid.err),arr.ind=T)         # Locate the smallest error in grid

my_palette <- colorRampPalette(c("black", "gray", "white"))(n = 299)   # Define a gray scale color palette

breaks<-quantile(as.matrix(grid.err),probs = seq(0, 1, 1/3))
col_breaks = c(seq(breaks[1],breaks[2],length=100),  # for black
               seq(breaks[2],breaks[3],length=100),  # for gray
               seq(breaks[3],breaks[4],length=100))  # for white

heatmap.2(data.matrix(grid.err), 
          xlab=expression(lambda),ylab="Pm",
          main = "Grid Search", # heat map title
          density.info="none",  # turns off density plot inside color legend
          trace="none",         # turns off trace lines inside the heat map
          col=my_palette,       # use on color palette defined earlier 
          breaks=col_breaks,    # enable color transition at specified limits
          dendrogram="none",    # no dendrogram
          Colv=NULL,Rowv=NULL)  
          mtext(paste0("Optimized Pm=",rownames(grid.err)[best.ind[1]]," lambda=",colnames(grid.err)[best.ind[2]]))

          

