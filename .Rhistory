return Rcpp::wrap(simdata);
'
## create the compiled function
rcppSim <- cxxfunction(signature(a="numeric",e="numeric"),code,plugin="RcppArmadillo")
cppFunction("arma::mat schur(arma::mat& a, arma::mat& b) { return(a % b); }", depends="RcppArmadillo")
library(Rcpp)
cppFunction("arma::mat schur(arma::mat& a, arma::mat& b) { return(a % b); }", depends="RcppArmadillo")
install.packages(libarmadillo)
install.packages("libarmadillo")
library(Rcpp)
cppFunction("arma::mat schur(arma::mat& a, arma::mat& b) { return(a % b); }", depends="RcppArmadillo")
library(Rcpp)
cppFunction("arma::mat schur(arma::mat& a, arma::mat& b) { return(a % b); }", depends="RcppArmadillo")
cppFunction("arma::mat schur(arma::mat& a, arma::mat& b) { return(a % b); }", depends="RcppArmadillo")
library(PGS)
?PGS
remove.packages(PGS)
remove.packages("PGS")
install.packages("https://github.com/YinanZheng/PGS/releases/download/PGS_v0.0.3/PGS_0.0.3.zip", repo = NULL, type = "binary")
library(PGS)
install.packages("https://github.com/YinanZheng/PGS/releases/download/PGS_v0.0.3/PGS_0.0.3.tgz", repo = NULL, type = "binary")
library(PGS)
library(RcppArmadillo)
library(Rcpp)
cpp.fun = cxxfunction(signature(x = "integer"),
plugin="RcppArmadillo",
body="
arma::vec y = arma::cumsum(as<arma::vec>(x));
return(wrap(y));
")
cpp.fun = cxxfunction(signature(x = "integer"),
plugin="RcppArmadillo",
body="
arma::vec y = arma::cumsum(as<arma::vec>(x));
return(wrap(y));
")
library(inline)
cpp.fun = cxxfunction(signature(x = "integer"),
plugin="RcppArmadillo",
body="
arma::vec y = arma::cumsum(as<arma::vec>(x));
return(wrap(y));
")
cpp.fun(c(1,2,2,3,1,3,2,3,1,2))
f <- cxxfunction(signature(),
+                  body=' Environment e = Environment::global_env();
+                         std::vector<double> vx = e["x"];
f <- cxxfunction(signature(),
body=' Environment e = Environment::global_env();
std::vector<double> vx = e["x"];
return wrap(vx); ',
plugin="Rcpp")
x <- 3:6
f()
x = matrix(1:30, nr=3)
x
x = matrix(1:30, nc=3)
x
f <- cxxfunction(signature(x = "numeric", i = "integer"),
body=' Environment e = Environment::global_env();
arma::mat x = as<arma::mat>(x)
arma::vec m_end = e["end"];
arma::vec m_start = e["start"];
return(wrap(x.rows(m_start[i], m_end[i]))); ',
plugin="RcppArmadillo")
f <- cxxfunction(signature(x = "numeric", i = "integer"),
body=' Environment e = Environment::global_env();
arma::mat x = as<arma::mat>(x)
arma::vec m_end = e["end"];
arma::vec m_start = e["start"];
return(wrap(x.rows(m_start(i), m_end(i))); ',
plugin="RcppArmadillo")
rcpp_inc <- '
using namespace Rcpp;
using namespace arma;
'
f <- cxxfunction(signature(x = "numeric", i = "integer"),
body=' Environment e = Environment::global_env();
mat x = as<mat>(x)
vec m_end = e["end"];
vec m_start = e["start"];
return(wrap(x.rows(m_start(i), m_end(i))); ',
plugin="RcppArmadillo", rcpp_inc)
f <- cxxfunction(signature(x = "numeric", i = "integer"),
body=' Environment e = Environment::global_env();
mat x = as<mat>(x);
vec m_end = e["end"];
vec m_start = e["start"];
return(wrap(x.rows(m_start(i), m_end(i))); ',
plugin="RcppArmadillo", rcpp_inc)
src <- '
mat m1 = as<mat>(m1in);
uvec idx = as<uvec>(idxin) - 1;
mat s1 = m1.rows(idx);
return(wrap(s1));
'
fn <- cxxfunction(signature(m1in="numeric", idxin="numeric"), src, plugin='RcppArmadillo', rcpp_inc)
f <- cxxfunction(signature(x = "numeric", i = "integer"),
body=' Environment e = Environment::global_env();
mat x_mat = as<mat>(x);
vec m_end = e["end"];
vec m_start = e["start"];
return(wrap(x_mat.rows(m_start(i), m_end(i))); ',
plugin="RcppArmadillo", rcpp_inc)
f <- cxxfunction(signature(x = "numeric", i = "integer"),
body=' Environment e = Environment::global_env();
mat x_mat = as<mat>(x);
vec m_end = e["end"];
vec m_start = e["start"];
mat res = x_mat.rows(m_start(i), m_end(i));
return(wrap(res); ',
plugin="RcppArmadillo", rcpp_inc)
f <- cxxfunction(signature(x = "numeric", i = "integer"),
body=' Environment e = Environment::global_env();
int ii = as<int>(i);
mat x_mat = as<mat>(x);
vec m_end = e["end"];
vec m_start = e["start"];
mat res = x_mat.rows(m_start(ii), m_end(ii));
return(wrap(res); ',
plugin="RcppArmadillo", rcpp_inc)
f <- cxxfunction(signature(x = "numeric", i = "integer"),
body=' Environment e = Environment::global_env();
int ii = as<int>(i);
mat x_mat = as<mat>(x);
vec m_end = e["end"];
vec m_start = e["start"];
mat res = x_mat.rows(m_start(ii), m_end(ii));
return(wrap(res)); ',
plugin="RcppArmadillo", rcpp_inc)
f2<-function(m,i){
x = matrix(1:30, nc=3)
end = cumsum(m)-1
start = end - m + 1
print(f(x,i))
}
f2(c(2,2,1,3,2), 2)
x = matrix(1:30, nc=3)
end = cumsum(m)-1
x = matrix(1:30, nc=3)
m = c(2,2,1,3,2)
end = cumsum(m)-1
start = end - m + 1
end
start
f2<-function(m,i){
x = matrix(1:30, nc=3)
end = cumsum(m)
end = cumsum(m)-1
start = end - m + 1
end
start
x = matrix(1:30, nc=3)
end = cumsum(m)-1
start = end - m + 1
end
start
f(x,i)
i=0
f(x,i)
f2(c(2,2,1,3,2), 0)
f2(c(2,2,1,3,2), 1)
x
f2(c(2,2,1,3,2), 2)
f2(c(2,2,1,3,2), 3)
f2<-function(m,i){
x = matrix(1:30, nc=3)
end = cumsum(m)-1
start = end - m + 1
print(f(x,i))
}
f2(c(2,2,1,3,2), 3)
library(RcppArmadillo)
library(Rcpp)
library(inline)
f <- cxxfunction(signature(x = "numeric", i = "integer"),
body=' Environment e = Environment::global_env();
int ii = as<int>(i);
mat x_mat = as<mat>(x);
vec m_end = e["end"];
vec m_start = e["start"];
mat res = x_mat.rows(m_start(ii), m_end(ii));
return(wrap(res)); ',
plugin="RcppArmadillo", rcpp_inc)
f2<-function(m,i){
x = matrix(1:30, nc=3)
end = cumsum(m)-1
start = end - m + 1
print(f(x,i))
}
f2(c(2,2,1,3,2), 3)
f2(c(2,2,1,3,2), 0)
f2<-function(m,i){
x = matrix(1:30, nc=3)
end <<- cumsum(m)-1
start <<- end - m + 1
print(f(x,i))
}
f2(c(2,2,1,3,2), 0)
f2<-function(m,i){
x = matrix(1:30, nc=3)
end = cumsum(m)-1
start <<- end - m + 1
end <<- end
print(f(x,i))
}
f2(c(2,2,1,3,2), 0)
?assign
library(Rcpp)
library(RcppArmadillo)
library(rbenchmark)
library(devtools)
library(roxygen2)
try(compileAttributes("/Users/yinanzheng2011/Desktop/PGS"),TRUE)
install.packages("/Users/yinanzheng2011/Desktop/PGS_0.1.0.tar.gz", repos = NULL)
library(PGS)
head(mirna)
head(pheno)
### Make sure the binary/categorical/ordinal variables are in "factor" format. In this example, "gender" and "cigwear" are binary variables
pheno$gender = factor(pheno$gender)
pheno$cigwear = factor(pheno$cigwear)
### Merge mirna and pheno dataset:
DATA <- merge(mirna, pheno, by=c("SID","WD"))
### Then the data must be sorted by study subject id and multiple measurement indicator;
DATA <- DATA[with(DATA, order(SID, WD)), ]
###############
### First we need to determine the rank of the biomarkers.
### This can be done by various ways.
### For example, rank by correlation with outcomes, or rank by p-values/t-statistics from site-by site statistical testing.
### In the example we used site-by-site testing:
y.vect<-DATA$FEV1              ### Extract dependent variable
id.vect<-DATA$SID              ### Extract subjuect id variable to indicate repeated measures
M<-DATA[,3:168]                ### Extract microRNA data matrix (row=samples, column=miRNA probes)
COV<-DATA[,170:179]            ### Extract covariate data matrix
##########---- Site-by-site testing using mixed effect model ######
# prerank_LMM_seq = preRank(y.vect, id.vect, M, COV, method = "LMM", parallel = F, write = F)
prerank_LMM_par = preRank(y.vect, id.vect, M, COV, method = "LMM", parallel = T, write = F)
preRank.vect = rownames(prerank_LMM_par)
(Pm.vect<-c(seq(10,50,10)))    ### Initiate Pm sequence: Number of top ranking biomarkers
(lam.vect<-seq(0.05, 0.5, 0.05))      ### Initiate lambda sequence: Penalty parameter of PGEE
PGS
PGSfit = PGS(y.vect, id.vect, M, COV, PS, Pm.vect, lam.vect, seed = 1)
y.vect
id.vect
PGSfit = PGS(y.vect, id.vect, M, COV, preRank.vect, Pm.vect, lam.vect, seed = 1)
PGSfit
res_par = PGSfit
L.Pm
L.Pm = length(Pm.vect)
grid.err = matrix(nrow = L.Pm, ncol = L.lam)   # Initiate error grid, column = lambda, row = Pm
lam.sel = rep(NA, L.Pm)  # Initiate optimized lambda for each Pm
beta.shrink.corr.list = vector("list", L.Pm)   # Initiate penalized Beta (coefficient) estimates for each Pm
var.sand.corr.list = vector("list", L.Pm)  # Initiate Variance
flag.stop.corr.list = rep(NA, L.Pm)
iter.n.corr.list = rep(NA, L.Pm)
L.lam = length(lam.vect)
grid.err = matrix(nrow = L.Pm, ncol = L.lam)   # Initiate error grid, column = lambda, row = Pm
lam.sel = rep(NA, L.Pm)  # Initiate optimized lambda for each Pm
beta.shrink.corr.list = vector("list", L.Pm)   # Initiate penalized Beta (coefficient) estimates for each Pm
var.sand.corr.list = vector("list", L.Pm)  # Initiate Variance
flag.stop.corr.list = rep(NA, L.Pm)
iter.n.corr.list = rep(NA, L.Pm)
for(i in 1:L.Pm)
{
temp.run = res_par[[i]]
grid.err[i,] <- temp.run$lam.cv.cor
lam.sel[i] <- temp.run$lam.sel.cor
beta.shrink.corr.list[[i]] <- temp.run$beta.shrink.cor
var.sand.corr.list[[i]] <- temp.run$var.sand.cor
flag.stop.corr.vect[i] <- temp.run$flag.stop.cor
iter.n.corr.vect[i] <- temp.run$iter.n.cor
}
# Initialize rooms to store results
grid.err = matrix(nrow = L.Pm, ncol = L.lam)   # Initiate error grid, column = lambda, row = Pm
lam.sel.vect = rep(NA, L.Pm)  # Initiate optimized lambda for each Pm
beta.shrink.corr.list = vector("list", L.Pm)   # Initiate penalized Beta (coefficient) estimates for each Pm
var.sand.corr.list = vector("list", L.Pm)  # Initiate Variance
flag.stop.corr.vect = rep(NA, L.Pm)
iter.n.corr.vect = rep(NA, L.Pm)
for(i in 1:L.Pm)
{
temp.run = res_par[[i]]
grid.err[i,] <- temp.run$lam.cv.cor
lam.sel.vect[i] <- temp.run$lam.sel.cor
beta.shrink.corr.list[[i]] <- temp.run$beta.shrink.cor
var.sand.corr.list[[i]] <- temp.run$var.sand.cor
flag.stop.corr.vect[i] <- temp.run$flag.stop.cor
iter.n.corr.vect[i] <- temp.run$iter.n.cor
}
rownames(grid.err) <- Pm.vect
colnames(grid.err) <- lam.vect
best.ind<-which(grid.err==min(grid.err),arr.ind=T)
beta<-beta.shrink.corr.list[[ best.ind[1] ]]
varb<-var.sand.corr.list[[ best.ind[1] ]]
se<-sqrt(varb)
sel.names<-c(preRank.vect[1:Pm.vect[best.ind[1]]],colnames(COV))
coefficients<-data.frame(Estimate = beta, Std.err = se, z = beta / se, P = 2*pnorm(abs(beta / se), lower.tail = F),
CI95.lower = beta - qnorm(0.975)*se, CI95.upper = beta + qnorm(0.975)*se)
rownames(coefficients) = sel.names
res = list(coefficients = coefficients,
grid.err = grid.err,
lam.sel = lam.sel,
flag.stop.corr = flag.stop.corr.vect[best.ind[1]],
iter.n.corr = iter.n.corr.vect[best.ind[1]],
Pm.vect = Pm.vect,
lam.vect = lam.vect)
res
res = list(coefficients = coefficients,
grid.err = grid.err,
lam.sel.vect = lam.sel.vect,
flag.stop.corr = flag.stop.corr.vect[best.ind[1]],
iter.n.corr = iter.n.corr.vect[best.ind[1]],
Pm.vect = Pm.vect,
lam.vect = lam.vect)
res
cat(paste0("Done!    (",Sys.time(),")\n"))
cat(paste0(">>> The best selection results achieved using top ",Pm.vect[best.ind[1]]," biomarkers with lambda = ",lam.vect[best.ind[2]]),"\n")
try(compileAttributes("/Users/yinanzheng2011/Desktop/PGS"),TRUE)
library(PGS)
head(mirna)
### "mirna" dataset contains 166 whole blood miRNAs expression data for 120 participants. Each participant has two measurement with 2 weeks apart.
### The miRNA expression data has been normalized across sample.
head(pheno)
### "pheno" dataset contains phenotype/clinical information of the 120 participants'
### FEV1: Forced expiratory volume in 1 second. This is one measurement of lung function. The goal is to find the associated miRNAs with lung function
### The other variables with lower case column names are potential confounders that we would like to adjust for.
### In this example data, the ID is "SID" column, the "WD" column indicates the examination day.
### Rows represent observation/record/measurement of each sample; Columns represent variables/biomarkers/predictors/;
### It is NOT necessary to scale the data
### Make sure the binary/categorical/ordinal variables are in "factor" format. In this example, "gender" and "cigwear" are binary variables
pheno$gender = factor(pheno$gender)
pheno$cigwear = factor(pheno$cigwear)
### Merge mirna and pheno dataset:
DATA <- merge(mirna, pheno, by=c("SID","WD"))
### Then the data must be sorted by study subject id and multiple measurement indicator;
DATA <- DATA[with(DATA, order(SID, WD)), ]
###############
### First we need to determine the rank of the biomarkers.
### This can be done by various ways.
### For example, rank by correlation with outcomes, or rank by p-values/t-statistics from site-by site statistical testing.
### In the example we used site-by-site testing:
y.vect<-DATA$FEV1              ### Extract dependent variable
id.vect<-DATA$SID              ### Extract subjuect id variable to indicate repeated measures
M<-DATA[,3:168]                ### Extract microRNA data matrix (row=samples, column=miRNA probes)
COV<-DATA[,170:179]            ### Extract covariate data matrix
##########---- Site-by-site testing using mixed effect model ######
# prerank_LMM_seq = preRank(y.vect, id.vect, M, COV, method = "LMM", parallel = F, write = F)
prerank_LMM_par = preRank(y.vect, id.vect, M, COV, method = "LMM", parallel = T, write = F)
preRank.vect = rownames(prerank_LMM_par)
(Pm.vect<-c(seq(30,160,10),166))    ### Initiate Pm sequence: Number of top ranking biomarkers
(lam.vect<-seq(0.02, 0.5, 0.02))      ### Initiate lambda sequence: Penalty parameter of PGEE
(lam.vect<-seq(0.02, 0.1, 0.02))      ### Initiate lambda sequence: Penalty parameter of PGEE
(Pm.vect<-c(seq(30,160,10),166))    ### Initiate Pm sequence: Number of top ranking biomarkers
(lam.vect<-seq(0.02, 0.2, 0.02))      ### Initiate lambda sequence: Penalty parameter of PGEE
PGS
PGSfit = PGS(y.vect, id.vect, M, COV, preRank.vect, Pm.vect, lam.vect, fold = 10, eps = 10^3, iter.n = 30, seed = 1)
plotGrid(PGSfit)
PGSfit = PGS(y.vect, id.vect, M, COV, preRank.vect, Pm.vect, lam.vect, fold = 10, eps = 1e-3, iter.n = 30, seed = 1)
plotGrid(PGSfit)
PGSfit = PGS(y.vect, id.vect, M, COV, preRank.vect, Pm.vect, lam.vect, fold = 10, eps = 1e-10, iter.n = 100, seed = 1)
plotGrid(PGSfit)
(lam.vect<-seq(0.02, 0.2, 0.05))      ### Initiate lambda sequence: Penalty parameter of PGEE
(lam.vect<-seq(0.02, 0.2, 0.5))      ### Initiate lambda sequence: Penalty parameter of PGEE
(lam.vect<-seq(0.02, 0.2, 0.5))      ### Initiate lambda sequence: Penalty parameter of PGEE
(lam.vect<-seq(0.02, 0.5, 0.02))      ### Initiate lambda sequence: Penalty parameter of PGEE
PGSfit = PGS(y.vect, id.vect, M, COV, preRank.vect, Pm.vect, lam.vect, fold = 10, eps = 1e-10, iter.n = 100, seed = 1)
plotGrid(PGSfit)
PGSfit
est = PGSfit$coefficients
subset(est,P<0.05)
subset(est,abs(Estimate)>0.001 & P<0.05)
library(Rcpp)
library(RcppArmadillo)
library(rbenchmark)
library(devtools)
library(roxygen2)
try(compileAttributes("/Users/yinanzheng2011/Desktop/PGS"),TRUE)
install.packages("/Users/yinanzheng2011/Desktop/PGS_0.1.0.tgz", repos = NULL)
library(PGS)
remove.packages("PGS")
install.packages("/Users/yinanzheng2011/Desktop/PGS_0.1.0.tgz", repos = NULL)
library(PGS)
head(mirna)
### "mirna" dataset contains 166 whole blood miRNAs expression data for 120 participants. Each participant has two measurement with 2 weeks apart.
### The miRNA expression data has been normalized across sample.
head(pheno)
pheno$gender = factor(pheno$gender)
pheno$cigwear = factor(pheno$cigwear)
### Merge mirna and pheno dataset:
DATA <- merge(mirna, pheno, by=c("SID","WD"))
### Then the data must be sorted by study subject id and multiple measurement indicator;
DATA <- DATA[with(DATA, order(SID, WD)), ]
y.vect<-DATA$FEV1              ### Extract dependent variable
id.vect<-DATA$SID              ### Extract subjuect id variable to indicate repeated measures
M<-DATA[,3:168]                ### Extract microRNA data matrix (row=samples, column=miRNA probes)
COV<-DATA[,170:179]            ### Extract covariate data matrix
##########---- Site-by-site testing using mixed effect model ######
# prerank_LMM_seq = preRank(y.vect, id.vect, M, COV, method = "LMM", parallel = F, write = F)
try(compileAttributes("/Users/yinanzheng2011/Desktop/PGS"),TRUE)
remove.packages("PGS")
install.packages("/Users/yinanzheng2011/Desktop/PGS_0.1.0.tgz", repos = NULL)
library(PGS)
preRank
preRank()
head(mirna)
head(pheno)
pheno$gender = factor(pheno$gender)
pheno$cigwear = factor(pheno$cigwear)
### Merge mirna and pheno dataset:
DATA <- merge(mirna, pheno, by=c("SID","WD"))
### Then the data must be sorted by study subject id and multiple measurement indicator;
DATA <- DATA[with(DATA, order(SID, WD)), ]
y.vect<-DATA$FEV1              ### Extract dependent variable
id.vect<-DATA$SID              ### Extract subjuect id variable to indicate repeated measures
M<-DATA[,3:168]                ### Extract microRNA data matrix (row=samples, column=miRNA probes)
COV<-DATA[,170:179]            ### Extract covariate data matrix
prerank_LMM_par = preRank(y.vect, id.vect, M, COV, method = "LMM", parallel = T, write = F)
library(PGS)
120^(1/3)
setwd("/Users/yinanzheng2011/Desktop")
install.packages("/Users/yinanzheng2011/Desktop/PGS_0.1.2.tgz", repos = NULL)
library(PGS)
?"PGS-package"
document()
library(Rcpp)
library(RcppArmadillo)
library(rbenchmark)
library(devtools)
library(roxygen2)
## Use RcppArmadillo skeleton is better..
# RcppArmadillo.package.skeleton("PGS")
compileAttributes("/Users/yinanzheng2011/Desktop/PGS")
document()
try(setwd("/Users/yinanzheng2011/Desktop/PGS"),TRUE)
library(Rcpp)
library(RcppArmadillo)
library(rbenchmark)
library(devtools)
library(roxygen2)
compileAttributes("/Users/yinanzheng2011/Desktop/PGS")
document()
?preRank
try(setwd("/Users/yinanzheng2011/Desktop/PGS"),TRUE)
library(Rcpp)
library(RcppArmadillo)
library(rbenchmark)
library(devtools)
library(roxygen2)
## Use RcppArmadillo skeleton is better..
# RcppArmadillo.package.skeleton("PGS")
document()
?preRank
library(PGS)
BJdata()
BJlung$gender = factor(BJlung$gender)
BJlung$heat = factor(BJlung$heat)
BJlung$cigwear = factor(BJlung$cigwear)
### Merge miRNA and lung function dataset.
BJ_dat <- merge(BJmirna, BJlung, by=c("SID","WD"))
### Then the data must be sorted by study subject id and multiple measurement indicator.
BJ_dat <- BJ_dat[with(BJ_dat, order(SID, WD)), ]
###############
### In the example we used site-by-site testing:
y.vect<-BJ_dat$FEV1              ### Extract dependent variable
id.vect<-BJ_dat$SID              ### Extract subjuect id variable to indicate repeated measures
M<-BJ_dat[,3:168]                ### Extract microRNA data matrix (row=samples, column=miRNA probes)
COV<-BJ_dat[,170:179]            ### Extract covariate data matrix
##########---- Site-by-site testing using mixed effect model ######
# prerank_LMM_seq = preRank(y.vect, id.vect, M, COV, method = "LMM", parallel = F, write = F)
prerank_LMM_par = preRank(y.vect, id.vect, M)
preRank.vect = prerank_LMM_par
# preRank.vect = prerank_GEE_par
(Pm.vect<-c(seq(10,160,10)))    ### Initiate Pm sequence: Number of top ranking biomarkers
(lam.vect<-seq(0.04, 0.16, 0.01))      ### Initiate lambda sequence: Penalty parameter of PGEE
PGSfit = pgsfit(y.vect, id.vect, M, COV, preRank.vect, Pm.vect, lam.vect, seed = 1)
PGSfit
(est = PGSfit$coefficients)
# subset(est,P<0.05)
subset(est,abs(Estimate)>0.001 & P<0.05)
plotGrid(PGSfit)
(lam.vect<-seq(0.04, 0.1, 0.01))      ### Initiate lambda sequence: Penalty parameter of PGEE
(Pm.vect<-c(seq(10,160,10)))    ### Initiate Pm sequence: Number of top ranking biomarkers
(lam.vect<-seq(0.04, 0.1, 0.01))      ### Initiate lambda sequence: Penalty parameter of PGEE
(Pm.vect<-c(seq(10,160,10)))    ### Initiate Pm sequence: Number of top ranking biomarkers
(lam.vect<-seq(0.04, 0.1, 0.01))      ### Initiate lambda sequence: Penalty parameter of PGEE
PGSfit = pgsfit(y.vect, id.vect, M, COV, preRank.vect, Pm.vect, lam.vect, seed = 1)
(est = PGSfit$coefficients)
# subset(est,P<0.05)
subset(est,abs(Estimate)>0.001 & P<0.05)
### Plot the Grid of CV error
plotGrid(PGSfit)
(lam.vect<-seq(0.05, 0.005, 0.01))      ### Initiate lambda sequence: Penalty parameter of PGEE
(lam.vect<-seq(0.05, 0.1, 0.005))      ### Initiate lambda sequence: Penalty parameter of PGEE
(Pm.vect<-c(seq(10,160,10)))    ### Initiate Pm sequence: Number of top ranking biomarkers
(lam.vect<-seq(0.05, 0.1, 0.005))      ### Initiate lambda sequence: Penalty parameter of PGEE
PGSfit = pgsfit(y.vect, id.vect, M, COV, preRank.vect, Pm.vect, lam.vect, seed = 1)
PGSfit
(est = PGSfit$coefficients)
# subset(est,P<0.05)
subset(est,abs(Estimate)>0.001 & P<0.05)
### Plot the Grid of CV error
plotGrid(PGSfit)
try(setwd("/Users/yinanzheng2011/Desktop/PGS"),TRUE)
library(Rcpp)
library(RcppArmadillo)
library(rbenchmark)
library(devtools)
library(roxygen2)
## Use RcppArmadillo skeleton is better..
# RcppArmadillo.package.skeleton("PGS")
compileAttributes("/Users/yinanzheng2011/Desktop/PGS")
document()
