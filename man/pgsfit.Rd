% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pgsfit.R
\name{pgsfit}
\alias{pgsfit}
\title{Penalized Generalized Estimation Equation with Grid Search}
\usage{
pgsfit(y.vect, id.vect, M, COV = NULL, preRank.obj, Pm.vect, lam.vect,
  fold = 10, eps = 1e-04, iter.n = 100, corstr = "ar1",
  parallel = TRUE, perm = TRUE, ncore = detectCores(), seed = NULL)
}
\arguments{
\item{y.vect}{a vector of dependent variable.}

\item{id.vect}{a vector of subjuect ID.}

\item{M}{a data frame or matrix of genomic dataset. Rows represent samples, columns represent genomic marks.}

\item{COV}{a data frame or matrix of covariates dataset.}

\item{preRank.obj}{a list object from \code{preRank} which contains a vector of strings specifying pre-ranked names of genomic marks and corresponding estimates. See \code{preRank}}

\item{Pm.vect}{a numeric vector of tunning parameter Pm, which specifies the number of top ranking genomic marks.}

\item{lam.vect}{a numeric vector of tunning parameter lambda, which specifies the penalty parameter.}

\item{fold}{k-fold cross-validation in calculating grid error. Default = 10.}

\item{eps}{convergence threshold. By default iteration stops when beta estimation error < 1e-4}

\item{iter.n}{maximum iteration number. Iteration will stop anyway even if the \code{eps} is not met and throw a warning. Default = 100.}

\item{corstr}{a character string specifying the working correlation structure. The following are permitted: independence (\code{"indep"}), exchangeable (\code{"exch"}), autoregressive(1) (\code{"ar1"}), and unstructured (\code{"un"}). Default = \code{"ar1"}.}

\item{parallel}{logical. Enable parallel computing feature. Default = \code{TRUE}.}

\item{perm}{logical. Enable permutation for variable selection. Defaul = \code{TRUE}}

\item{ncore}{number of cores to run parallel computation. Effective when \code{parallel} = \code{TRUE}. By default, max number of cores will be used.}

\item{seed}{an integer specifying seed for cross-validation. If not specified \code{pgsfit} will generate one.}
}
\value{
Fitting and variable penalization results; a list object \code{pgsobj} consisting of:
  \item{coefficients}{estimates (shrinked) from the best model}
  \item{grid.err}{cross-validation error grid}
  \item{lam.sel.vect}{vector of selected lambda}
  \item{convergenceError}{convergence error when iteration stopped}
  \item{iterationNumber}{iteration times when converged}
  \item{which.bestPm}{index of the best Pm among convergent results}
  \item{which.bestLambda}{index of the best Lambda among convergent results}
  \item{which.bestPmGlobal}{index of the best Pm among all results (including non-convergent results)}
  \item{which.bestLambdaGlobal}{index of the best Lambda among all results (including non-convergent results)}
  \item{hat.R.corr}{estimated working correlation matrix}
  \item{convergenceThreshold}{threshold of convergence error (i.e. \code{eps})}
  \item{maxIteration}{maximum iteration number allowed (i.e. \code{iter.n})}
  \item{Pm.vect}{working vector of tunning parameter Pm}
  \item{lam.vect}{working vector of tunning parameter lambda}
  \item{convergeMessage}{"Converged!" or "Not converged!"}
}
\description{
\code{pgsfit} is used to fit and determine the best results from penalized GEE method across pre-specified tunning parameter grid.
}
\examples{
### Dataset preview
BJdata()

### Convert binary variables into factor type
BJlung$gender = factor(BJlung$gender)
BJlung$heat = factor(BJlung$heat)
BJlung$cigwear = factor(BJlung$cigwear)

### Merge miRNA and lung function dataset
BJdata <- merge(BJmirna, BJlung, by=c("SID","WD"))

### Data must be sorted by study subject ID and multiple measurements indicator
BJdata <- BJdata[with(BJdata, order(SID, WD)), ]

### Extract dependent variable (lung function)
y.vect<-BJdata$FEV1

### Extract subjuect ID variable indicating repeated measures            
id.vect<-BJdata$SID        

### Extract microRNA data matrix   
M<-BJdata[,3:168]   

### Extract covariate data matrix       
COV<-BJdata[,170:179]
           
### In the example we use linear mixed-effect model (default) for pre-ranking, ranked by p-values
prerank_LMM_par = preRank(y.vect, id.vect, M, COV)

### Initiate Pm sequence: Number of top ranking genomic marks
(Pm.vect<-c(seq(10,60,10)))

### Initiate lambda sequence: Penalty parameter
(lam.vect <- exp(-seq(2,3.5, length = 30)))     

### If your computer have multiple cores, it is recommended to enable parallel option (default)
PGSfit = pgsfit(y.vect, id.vect, M, COV, preRank_LMM_par, Pm.vect, lam.vect, seed = 1)
}
\seealso{
see \code{\link{preRank}} to obtain proper ranked genomic marks. see \code{\link{plotGrid}} to visualize and diagnose fitting results.
}

